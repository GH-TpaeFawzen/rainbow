#!/usr/bin/env python
# ----------------------------------------------------------------------
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ----------------------------------------------------------------------

from optparse import OptionParser, OptionGroup
import ConfigParser
import random
import sys
import re
import os


# ----------------------------------------------------------------------
# Constants & variables
# ----------------------------------------------------------------------

COLOREX_HOME = os.path.join(os.sep,'usr','share','colorex')
"""
The location where colorex assets are stored.

@type: string
"""

COLOREX_CONFIGS_HOME = os.path.join(COLOREX_HOME,'configs')
"""
The location where colorex configs are stored.

@type: string
"""

USER_CONFIGS_HOME = os.path.expanduser('~/.colorex')
"""
The location where colorex user-defined configs are stored.

@type: string
"""

VERSION_FILE = os.path.join(COLOREX_HOME,'VERSION')
"""
The location of the file containing the script version number.

@type: string
"""

USAGE = "%prog [options] [file...] "
"""
A string showing the script usage syntax.

@type: string
"""

DESCRIPTION = """Display files or STDIN with pretty colors for matched patterns. If you don't specify
files, stdin is used. For more information, see colorex man page."""
"""
A string describing the script.

@type: string
"""

FILTERS = {
  'red':                { 'short_option': 'r', 'help': 'display RED pattern in red',                                  'filter_start': chr(27)+'[31m', 'filter_end': chr(27)+'[39m' },
  'green':              { 'short_option': 'g', 'help': 'display GREEN pattern in green',                              'filter_start': chr(27)+'[32m', 'filter_end': chr(27)+'[39m' },
  'yellow':             { 'short_option': 'y', 'help': 'display YELLOW pattern in yellow',                            'filter_start': chr(27)+'[33m', 'filter_end': chr(27)+'[39m' },
  'blue':               { 'short_option': 'b', 'help': 'display BLUE pattern in blue',                                'filter_start': chr(27)+'[34m', 'filter_end': chr(27)+'[39m' },
  'magenta':            { 'short_option': 'm', 'help': 'display MAGENTA pattern in magenta',                          'filter_start': chr(27)+'[35m', 'filter_end': chr(27)+'[39m' },
  'cyan':               { 'short_option': 'c', 'help': 'display CYAN pattern in cyan',                                'filter_start': chr(27)+'[36m', 'filter_end': chr(27)+'[39m' },
  'bred':               { 'short_option': 'R', 'help': 'display BRED pattern in red background',                      'filter_start': chr(27)+'[41m', 'filter_end': chr(27)+'[49m' },
  'bgreen':             { 'short_option': 'G', 'help': 'display BGREEN pattern in green background',                  'filter_start': chr(27)+'[42m', 'filter_end': chr(27)+'[49m' },
  'byellow':            { 'short_option': 'Y', 'help': 'display BYELLOW pattern in yellow background',                'filter_start': chr(27)+'[43m', 'filter_end': chr(27)+'[49m' },
  'bblue':              { 'short_option': 'B', 'help': 'display BBLUE pattern in blue background',                    'filter_start': chr(27)+'[44m', 'filter_end': chr(27)+'[49m' },
  'bmagenta':           { 'short_option': 'M', 'help': 'display BMAGENTA pattern in magenta background',              'filter_start': chr(27)+'[45m', 'filter_end': chr(27)+'[49m' },
  'bcyan':              { 'short_option': 'C', 'help': 'display BCYAN pattern in cyan background',                    'filter_start': chr(27)+'[46m', 'filter_end': chr(27)+'[49m' },
  'bold':               {                      'help': 'display BOLD pattern in bold',                                'filter_start': chr(27)+'[1m',  'filter_end': chr(27)+'[22m' },
  'faint':              {                      'help': 'display FAINT pattern in decreased intensity',                'filter_start': chr(27)+'[2m',  'filter_end': chr(27)+'[22m' },
  'italic':             {                      'help': 'display ITALIC pattern in italic',                            'filter_start': chr(27)+'[3m',  'filter_end': chr(27)+'[23m' },
  'underline':          {                      'help': 'display UNDERLINE pattern double underlined',                 'filter_start': chr(27)+'[4m',  'filter_end': chr(27)+'[24m' },
  'underline-double':   {                      'help': 'display UNDERLINE_DOUBLE pattern underlined',                 'filter_start': chr(27)+'[21m', 'filter_end': chr(27)+'[24m' },
  'blink':              {                      'help': 'display BLINK pattern blinking',                              'filter_start': chr(27)+'[5m',  'filter_end': chr(27)+'[25m' },
  'blink-rapid':        {                      'help': 'display BLINK pattern blinking',                              'filter_start': chr(27)+'[6m',  'filter_end': chr(27)+'[25m' },
  'negative':           {                      'help': 'display NEGATIVE pattern swapping foreground and background', 'filter_start': chr(27)+'[7m',  'filter_end': chr(27)+'[27m' },
  'hide':               {                      'help': 'hide HIDE pattern',                                           'filter_start': chr(27)+'[8m',  'filter_end': chr(27)+'[28m' }
 }
"""
A dictionary of the filters available in the scripts.

The filter name defines the command line long option name. The other fields are self-explanatory.

@type: dict
"""

FILTER_GROUPS = [
  { 'name': 'Text color',
    'help': 'Use these options to associate patterns to text colors.',
    'filters': [ 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan' ] },
  { 'name': 'Background color',
    'help': 'Use these options to associate patterns to text background colors.',
    'filters': [ 'bred', 'bgreen', 'byellow', 'bblue', 'bmagenta', 'bcyan' ] },
  { 'name': 'Formatting',
    'help': 'Use these options to associate patterns to text formattings. Some of the filters do not work on all terminals.',
    'filters': [ 'bold', 'faint', 'italic', 'underline', 'underline-double', 'blink', 'blink-rapid', 'negative', 'hide' ] }
 ]
"""
A dictionary defining groups of filters.

This is used to make the C{--help} option output easier to read.

@type: string
"""

patterns = {}
"""
The dictionary containing patterns registered through configs and command line options.

@type: dict
"""

optionParser = OptionParser(usage=USAGE, version="%prog " + open(VERSION_FILE, 'r').readline(), description=DESCRIPTION)
"""
The parser used to handle command line arguments.

@type: OptionParser
"""


# ----------------------------------------------------------------------
# Functions
# ----------------------------------------------------------------------


def register_pattern_with_filter(pattern,filter_name):
    """
    Register a pattern to be processed by a filter.

    This functions populates the L{patterns} dictionary.

    @param pattern: the pattern (regular expression).
    @type pattern: string
    @param filter_name: the filter to associate with the pattern. It must be a key of L{FILTERS}.
    @type filter_name: string
    @rtype: void
    """

    # If this is new pattern, create a new entry with the corresponding compiled regex.    
    if pattern not in patterns:
        patterns[pattern] = { 'pattern_start': '',
                              'pattern_end': '',
                              'regex' : re.compile(pattern) }

    # Update the pattern before and after strings with the filter ones.
    patterns[pattern]['pattern_start'] += FILTERS[filter_name]['filter_start']
    patterns[pattern]['pattern_end'] += FILTERS[filter_name]['filter_end']


def handle_command_line_pattern_option(option, opt, value, parser):
    """
    Handle a command line option defining a pattern/filter association.
    
    @param option: the Option instance calling the callback.
    @type option: Option
    @param opt: the option string seen on the command-line.
    @type opt: string
    @param value: the argument to this option seen on the command-line.
    @type value: string
    @param parser: the OptionParser instance.
    @type parser: OptionParser
    @rtype: void
    """

    # The pattern is the option value, the filter name is computed from the option name ("--filter").
    register_pattern_with_filter(value,option.get_opt_string()[2:])


def process_config(config):
    """
    Try to locate a config, and then register every pattern <-> filter association defined within it.

    @param config: the config file to look for. The function will look for (in the following order):
        - C{config}
        - C{config.cfg}
        - C{L{USER_CONFIGS_HOME}/config}
        - C{L{USER_CONFIGS_HOME}/config.cfg}
        - C{L{COLOREX_CONFIGS_HOME}/config}
        - C{L{COLOREX_CONFIGS_HOME}/config.cfg}
    @type config: string
    @rtype: void
    """

    # Try to locate the config.
    if os.path.isfile(config):
        config_file = config
    elif os.path.isfile(config + '.cfg'):
        config_file = config + '.cfg'
    elif os.path.isfile(os.path.join(USER_CONFIGS_HOME,config)):
        config_file = os.path.join(USER_CONFIGS_HOME,config)
    elif os.path.isfile(os.path.join(USER_CONFIGS_HOME,config + '.cfg')):
        config_file = os.path.join(USER_CONFIGS_HOME,config + '.cfg')
    elif os.path.isfile(os.path.join(COLOREX_CONFIGS_HOME,config)):
        config_file = os.path.join(COLOREX_CONFIGS_HOME,config)
    elif os.path.isfile(os.path.join(COLOREX_CONFIGS_HOME,config + '.cfg')):
        config_file = os.path.join(COLOREX_CONFIGS_HOME,config + '.cfg')
    else:
        sys.stderr.write("ERROR : Could not locate the config %s.\n" % config)
        return

    # Parse the configuration file and register patterns defined within it.
    configParser = ConfigParser.ConfigParser()
    configParser.read(config_file)
    for filter in configParser.options("filters"):
        if filter in FILTERS:
            register_pattern_with_filter(configParser.get("filters",filter),filter)
        else:
            sys.stderr.write("ERROR: unknown filter '%s'.\n" % filter)


def apply_filters(line):
    """
    Colorize the line using the L{patterns} dictionary.

    @param line: the line to process.
    @type line: string
    @return: the processed line.
    @rtype: string
    """

    # Look for each pattern registered.
    for (pattern,pattern_filter) in patterns.items():

        # Apply filter for each match.
        for match in pattern_filter['regex'].finditer(line):
            line = line.replace(match.group(),pattern_filter['pattern_start'] + match.group() + pattern_filter['pattern_end'])

    return line.rstrip()



# ----------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------

# Setup the command line option parser
optionParser.formatter.max_help_position = 50
optionParser.formatter.width = 100

# Register the "--config" command line option.
optionParser.add_option("-f",
                        "--config",
                        action="append",
                        dest="config",
                        type="string",
                        help="Load a config file defining patterns. Go to " + COLOREX_CONFIGS_HOME + " for examples.")

# Walk through filter groups and register each filter as a command line option.
for filter_group in FILTER_GROUPS:
    filter_option_group = OptionGroup(optionParser, filter_group['name'], filter_group['help'])
    for filter_name in filter_group['filters']:
        filter = FILTERS[filter_name]
        if 'short_option' in filter:
            filter_option_group.add_option("-" + filter['short_option'],
                                           "--" + filter_name, action="callback",
                                           callback=handle_command_line_pattern_option,
                                           type="string",
                                           help=filter['help'])
        else:
            filter_option_group.add_option("--" + filter_name,
                                           action="callback",
                                           callback=handle_command_line_pattern_option,
                                           type="string",
                                           help=filter['help'])
    optionParser.add_option_group(filter_option_group)

# Parse command line options.
(options, args) = optionParser.parse_args()

# If configs passed, process them.
if options.config:
    for config in options.config:
        process_config(config)

try:
    # If files passed to the command lines, process each one of them, line by line.
    if args:
        for file in args:
            try:
                file_handle = open(file, 'r')
                for line in file_handle:
                    print apply_filters(line)
            except Exception,info:
                sys.stderr.write("ERROR : can't read file %s\n" % file)
                sys.stderr.write(str(info) + '\n')
            finally:
                file_handle.close()

    # Else process STDIN.
    else:
        try:
            while True:
                print apply_filters(raw_input())
        except KeyboardInterrupt:
            # Let a chance to the interrupted process to finish.
            while True:
                print apply_filters(raw_input())

# Exit on keyboard interrupt and end of file.
except (EOFError, KeyboardInterrupt):
    sys.exit(0)

# Raise an error for any other exception.
except Exception, info:
    sys.stderr.write("ERROR : %s\n" % info)
    sys.exit(1)
